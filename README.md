# Tiled


创建型模式		
用于创建对象			
工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。共五种。
口诀：单抽元件（建）厂

结构型模式		
处理类或对象的组合		
适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。共七种。
口诀：外侨（桥）组员（元）戴（代）配饰。

行为型模式		
描述类与对象怎样交互、怎样分配职责		
策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。共十一种。
口诀：观摩（模）对（迭）策，责令解放（访），戒（介）忘台（态）。




创建型

AbstractFactory抽象工厂		
提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。产品对象族。

Builder建造者				
将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。如何建立一个组合对象。

FactoryMethod（类）工厂方法	
定义一个用于创建对象的接口，让子类决定将哪一个类实例化。使一个类的实例化延迟到其子类。实例化子类对象。

Prototype原型				
用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。实例化类的对象。

Singleton单例				
保证一个类仅有一个实例，并提供一个访问它的全局访问点。类的单个实例。
				
结构型

Adapter（类）				
适配器将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。与对象的接口。

Bridge桥接					
将抽象部分与它的实现部分分离，使它们都可以独立地变化。对象的实现。

Composite组合模式			
将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得客户对单个对象和复合对象的使用具有一致性。对象的结构和组合。

Decorator装饰模式			
动态地给一个对象添加一些额外的职责。就扩展功能而言，Decorator模式比生成子类方式更为灵活。无子类对象责任。

Facade外观模式				
为子系统中的一组接口提供一个一致的界面，外观模式通过提供一个高层接口，隔离了外部系统与子系统间复杂的交互过程，使得复杂系统的子系统更易使用。与子系统的接口。

Flyweight享元模式			
运用共享技术有效地支持大量细粒度的对象。对象的存储代价。

Proxy代理模式				
为其他对象提供一种代理以控制对这个对象的访问。代理模式使用代理对象完成用户请求，屏蔽用户对真实对象的访问。如何访问对象对象位置。
				
行为型		
		
Chain of Responsibility责任链模式	
避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。可满足请求的对象。

Iterator迭代器模式			
提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。如何访问、遍历聚集的元素。

Mediator中介者模式			
用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。对象之间如何交互以及哪些对象交互。

Memento备忘录模式			
在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态。何时及哪些私有信息存储在对象之外。

Observer观察者模式			
观察者模式定义了对象间的一种一对多依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。信赖于另一对象的对象数量，信对象如何保持最新数据。

State状态模式				
允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。对象的状态。

Strategy策略模式			
策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。算法。

Command命令模式				
将一个请求封装成一个对象，从而使得用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。何时及如何满足一个请求。

Interpreter（类）解释器模式	
给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。语言的语法和解释。

Template Method（类）模板方法
定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。算法的步骤。

Visitor访问者模式			
表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用与这些元素的新操作。即对于某个对象或者一组对象，不同的访问者，产生的结果不同，执行操作也不同。无须改变其类而可应用于对象的操作。
			

https://blog.csdn.net/qq_31803267/article/details/125318136
C# .Net设计模式与代码实现(一)——创建型模式

https://blog.csdn.net/qq_31803267/article/details/125330992
C# .Net设计模式与代码实现(二)——结构型模式

https://blog.csdn.net/qq_31803267/article/details/125344589
C# .Net设计模式与代码实现(三)——行为型模式




https://blog.csdn.net/weixin_61361738/article/details/128824039
线性结构
1.数组（Array）
2.链表（Linked List）
3.栈（Stack）
4.队列（Queue）
5.哈希表（Hash）
非线性结构
1.树（Tree）
2.堆（Heap）
3.图（Graph）

https://www.cnblogs.com/HONT/archive/2013/06/05/3118531.html
哈夫曼编码的C#实现